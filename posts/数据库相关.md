---
abbrlink: ''
categories: []
date: '2024-06-25'
description: ''
tags:
- 数据库
- Redis
title: 数据库相关
updated: '2024-06-25T18:03:41.597+08:00'
---
# 数据库

## 三大范式

1. 属性不可再分
2. 消除非主属性部分依赖，非主属性必须完全依赖于主键而不是主键的一部分
3. 消除非主属性传递依赖，避免数据冗余

## MYSQL

- 分库分表迁移：停机迁移、双写方案
- InnoDB数据按页为单位读写，默认16KB。一个区大小为1MB，使链表中相邻页的物理位置相邻，顺序IO
- 行格式：变长字段长度列表、NULL列表、记录头信息、row_id、trx_id、roll_ptr、真实数据
  - 变长字段与NULL逆序存储，便于CPU cache命中
  - NULL至少1字节
  - row_id 6字节，只在没有主键和唯一约束时存在
  - trx_id事务id，6字节；roll_pointer版本指针，7字节
  - varchar(n) n为最大存放字符数，一行数据最大字节数为65535，-1 NULL，-2 变长字段，因此n最大为65532
  - 一个数据页只能存储16KB，Compact记录部分数据，剩余数据存在20字节指向的溢出页中；Compressed和Dynamic溢出的数据全部存在溢出页中

### 命令

- drop删除表，truncate删除表中数据
- join

### 事务

- InnoDB默认可重复读，MyISAM不支持事务
  - 快照读使用MVCC避免幻读，当前读使用next-key lock避免幻读
  - MVCC不能完全避免幻读，例如事务先执行快照读，再执行当前读；解决方法是在开启事务后马上执行当前读，加入next-key lock
  - 可重复读在启动事务时生成快照，整个事务期间都使用这个快照
  - 提交读在每次读取数据时生成新的快照

### 锁

update的where条件带索引就只会对索引加锁，不带索引会对全表加锁

- 全局锁：flush tables with read lock / unlock tables
- 表级锁：lock tables read / write
  - 表锁
  - 元数据锁：针对表结构操作，注意长事务可能堵塞后续select
  - 意向锁：快速判断表里是否有记录被加锁，不会和行级锁冲突，意向锁之间也无冲突
  - AUTO-INC锁：插入语句执行完成后立即释放
- 行级锁：lock in share mode / for update，MyISAM不支持行级锁
  - Record Lock
  - Gap Lock，不能插入数据，间隙锁不互斥
  - Next-Key Lock，记录锁+间隙锁，有可能会退化成记录或间隙锁
  - 插入意向锁：当插入时其他事务加了间隙锁，就会生成插入意向锁

死锁避免：设置事务等待锁的超时时间、开启主动死锁检测、订单做幂等性校验，设为唯一索引

### 索引

按物理特性分：

- 聚簇索引：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。叶节点存储的是主键，可能需要回表查询
  - 覆盖索引：索引覆盖了所有需要查询的字段，不需要回表
  - 遍历二级索引成本要比聚簇索引低

按数据结构分：

- B+树：与B树相比，具备更少的IO次数（非叶节点不存储数据）、更稳定的查询效率（千万级数据3-4层）和更适于范围查询这些优势。
- Hash
- Full-Text

按字段特性分：

- 主键索引：没有主键会选择第一个不含NULL的唯一列，再没有会使用隐式自增id
- 唯一索引：属性不能重复，但是可以为NULL，通常用于保证数据唯一
- 普通索引
- 前缀索引：对字符类型字段的前几个字符建立的索引，减少存储空间

索引下推：减少二级索引在查询时的回表操作，提高查询的效率，将在Server层执行的判断交给存储层处理。二级查询的叶节点存储的是主键

### 索引优化

[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

- 最左前缀匹配原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配
- 尽量选择区分度高的列作为索引
- 经常用于GROUP BY和ORDER BY的字段可以作为索引
- 索引列不能参与计算
- 尽量的扩展索引，不要新建索引
- EXPLAIN 命令，对 SELECT 语句进行分析，rows 越小越好
  - type: All, index, range, ref(非唯一索引扫描), eq_ref(唯一索引扫描), const(使用了主键或者唯一索引与常量值进行比较)
  - extra: Using filesort(排序，效率低), Using temporary(临时表，效率低), Using index(覆盖索引)

## Redis

常用命令：

- SETNX key value，当键不存在时才设置，可以用来实现分布式锁和防止缓存击穿，设置过期时间

为什么Redis是单线程：简单，容易维护，CPU、不是瓶颈，多线程存在死锁、上下文切换等问题影响性能
为什么引入多线程：提高网络 IO 读写性能

### 持久化

1. RDB，快照
   - save，同步保存，阻塞主线程
   - bgsave，fork出子进程执行
2. AOF，记录执行操作，根据fsync策略写入AOF文件中
   - always，性能低
   - everysec
   - no，主线程调用write后立刻返回，操作系统决定何时fsync
3. 混合持久化，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头，快速加载同时避免丢失过多的数据

### 性能优化

- 批量操作减少RTT

### 一致性哈希算法

用于分布式系统的负载均衡，解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。

对$2^{32}$取模，将节点和数据都映射到环上，结果顺时针找到的第一个节点就是存储数据的节点。增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点。

节点分布不均匀问题：使用虚拟节点，将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点。增大了节点数量，节点分布更加均匀，且节点变化时的稳定性更高。

### Hash Slot

redis cluster有固定的16384个hash slot，redis cluster中每个master都会持有部分slot。增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去

### Redis缓存及一致性、雪崩、击穿与穿透问题

- 先删后改，延时双删等方案，在高并发情况下还是会造成数据的不一致性，所以要保证强一致性就不要走缓存
- 缓存雪崩：过期时间的设置有可能导致大量的热点key在同一时间内全部失效，此时来了大量请求访问这些key，db被打宕
  - 设置热点数据永不过期
  - 错开过期时间的设置
  - 使用分布式锁或者MQ队列使得请求串行化（性能会受影响）
  - Redis集群（针对Redis不可用）
- 缓存穿透：请求参数不合理，不断查询缓存中不存在的不合理参数
  - 做IP限流与黑名单
  - 请求非法校验
  - 将db不存在的数据写入redis
  - 布隆过滤器
- 缓存击穿：某一个热点key突然过期
  - 设置热点key永不过期
  - 热点数据提前预热
  - 加锁，缓存失效时先用setnx设置一个mutex，成功后再删除，确保只有一个请求去查询数据库并更新缓存
- hotkey
  - 读写分离
  - 使用 Redis Cluster
  - 二级缓存，将 hotkey 存放一份到 JVM 本地内存中

### 淘汰策略与删除策略

内存淘汰策略（分为volatile，allkeys）：lru, lfu, ttl, random, no-eviction

删除策略：定时删除、惰性删除、定期删除。
Redis过期删除策略： 定期删除+惰性删除，周期性随机抽取key，受到执行时间和过期 key 的比例的影响

### 高可用

持久化、复制（基础）、哨兵（主节点存活检测、自动故障恢复）、 集群

主从复制 + 哨兵模式

主观下线：没有收到目标节点的有效回复
客观下线：主节点 出现故障，向其他Sentinel询问

### 缓存读写策略

[小林coding](https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98)

1. 旁路缓存模式，适合读多写少。写：先更新db，再删除缓存（由于缓存写入快，并发问题概率不高）；读：先读cache，再读db，写入cache
   - 若删除缓存失败，可以增加缓存更新重试机制，或者订阅binlog日志
   - 对缓存命中率要求高，可以使用更新数据库+更新缓存，加入分布式锁以及给缓存加上较短的过期时间
   - 针对「先删除缓存，再更新数据库」方案，延迟双删，睡眠一段时间再次删除缓存
2. 读写穿透，写：先查cache，不存在则更新db，存在先更新cache，cache再更新db
3. 异步缓存写入：只更新缓存，异步更新db
